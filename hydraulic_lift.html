<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pascal's Law: Hydraulic Lift Lab</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #0f172a;
      color: #e2e8f0;
      margin: 0;
      padding: 0;
      overflow: hidden;
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    #dashboard {
      width: 390px;
      background: #1e293b;
      border-right: 2px solid #334155;
      padding: 20px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
      z-index: 10;
    }

    #simulation {
      flex: 1;
      position: relative;
      background: #0f172a;
    }

    h2 {
      text-align: center;
      color: white;
      margin: 0 0 10px 0;
      font-size: 1.35rem;
    }

    .panel {
      background: #334155;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }

    .input-row { margin-bottom: 12px; }
    .input-row:last-child { margin-bottom: 0; }

    label {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: #94a3b8;
      font-weight: bold;
      gap: 10px;
    }

    .val {
      color: #38bdf8;
      font-family: monospace;
      font-size: 14px;
      white-space: nowrap;
    }

    input[type="range"], select {
      width: 100%;
      margin-top: 6px;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #475569;
      background: #0f172a;
      color: #e2e8f0;
      font-size: 14px;
    }

    input[type="range"] {
      padding: 0;
      accent-color: #38bdf8;
      cursor: pointer;
      background: transparent;
      border: none;
    }

    .btn-group { display: flex; gap: 10px; margin-top: 8px; }
    button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.1s;
      color: white;
      text-transform: uppercase;
    }

    #pushBtn { background: #e11d48; user-select: none; touch-action: none; }
    #pushBtn:active { background: #be123c; transform: scale(0.98); }

    #resetBtn { background: #0ea5e9; }
    #resetBtn:active { background: #0284c7; transform: scale(0.98); }

    .telemetry {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-family: monospace;
      font-size: 13.5px;
      color: #a7f3d0;
    }

    .telemetry span {
      display: flex;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      padding-bottom: 4px;
      gap: 8px;
    }

    .telemetry span:last-child { border-bottom: none; padding-bottom: 0; }
    .telemetry b { color: #fff; white-space: nowrap; }

    .alert-text { color: #f87171 !important; }
    .success-text { color: #4ade80 !important; }

    .math-box {
      background: rgba(0,0,0,0.25);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #fde047;
      border-left: 4px solid #fde047;
      margin-top: 5px;
      line-height: 1.35;
    }

    .hint {
      color: #cbd5e1;
      font-size: 12px;
      margin-top: 6px;
      line-height: 1.35;
    }

    .muted {
      color: #94a3b8;
      font-size: 12px;
      margin-top: 4px;
    }

    canvas#simCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #warningMsg {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #ef4444;
      color: white;
      padding: 10px 20px;
      border-radius: 30px;
      font-weight: bold;
      font-size: 1rem;
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      white-space: nowrap;
      z-index: 5;
    }

    @media (max-width: 800px) {
      body { flex-direction: column; overflow-y: auto; }
      #dashboard { width: 100%; border-right: none; border-bottom: 2px solid #334155; }
      #simulation { height: 58vh; min-height: 380px; flex: none; }
      #warningMsg { font-size: 0.9rem; }
    }
  </style>
</head>
<body>

  <audio id="liftSound" src="hydraulic_lift.mp3" preload="auto" loop></audio>

  <aside id="dashboard">
    <h2>Hydraulic Lift (Pascal's Law)</h2>

    <div class="panel">
      <div class="input-row">
        <label>Input Mass (m₁) <span class="val" id="m1Val">50 kg</span></label>
        <input type="range" id="m1Slider" min="10" max="200" step="1" value="50">
      </div>

      <div class="input-row">
        <label>Input Area (A₁) <span class="val" id="a1Val">0.20 m²</span></label>
        <input type="range" id="a1Slider" min="0.1" max="1.0" step="0.05" value="0.2">
      </div>

      <div class="input-row" style="margin-top: 15px; border-top: 1px solid #475569; padding-top: 15px;">
        <label>Output Area (A₂) <span class="val" id="a2Val">2.0 m²</span></label>
        <input type="range" id="a2Slider" min="1.0" max="10.0" step="0.5" value="2.0">
      </div>

      <div class="input-row">
        <label>Load Type</label>
        <select id="loadTypeSelect">
          <option value="vehicle">Vehicle preset</option>
          <option value="custom">Custom mass (slider)</option>
        </select>
      </div>

      <div class="input-row" id="vehicleRow">
        <label>Vehicle (preset)</label>
        <select id="vehicleSelect">
          <option value="900">Small car (900 kg)</option>
          <option value="1300" selected>Medium car (1300 kg)</option>
          <option value="1700">Slightly bigger car (1700 kg)</option>
        </select>
      </div>

      <div class="input-row" id="m2Row" style="display:none;">
        <label>Output Mass (m₂) <span class="val" id="m2Val">1300 kg</span></label>
        <input type="range" id="m2Slider" min="500" max="5000" step="100" value="1300">
        <div class="muted">Use this for any load (not only cars).</div>
      </div>

      <div class="hint">
        Press and hold the red button to apply pressure on the small piston.
      </div>

      <div class="btn-group">
        <button id="pushBtn">PRESS & HOLD<br>TO PUSH (P₁)</button>
        <button id="resetBtn" onclick="resetLift()">RESET<br>HEIGHT</button>
      </div>
    </div>

    <div class="panel">
      <div class="telemetry">
        <span>Input Force (F₁ = m₁g): <b id="f1Live">0.0 N</b></span>
        <span>Fluid Pressure (P = F₁/A₁): <b id="pLive">0.0 Pa</b></span>
        <span style="margin-top: 8px;">Load Weight (W = m₂g): <b id="wLive">0.0 N</b></span>
        <span style="color: #38bdf8;">Theor. Lift Force (F₂ = P·A₂): <b id="f2Live">0.0 N</b></span>
        <span style="margin-top: 8px;">Mechanical Advantage (A₂/A₁): <b id="maLive">0.00</b></span>
      </div>
    </div>

    <div class="math-box" id="calcContent">
      <strong>Pascal's Principle</strong><br>
      P = F₁/A₁ = F₂/A₂<br><br>
      <strong>Using g = 10 m/s²</strong><br><br>
      <strong>System Status:</strong><br>
      <span id="statusText">Awaiting input...</span>
    </div>
  </aside>

  <main id="simulation">
    <div id="warningMsg">⚠️ INSUFFICIENT FORCE TO LIFT LOAD</div>
    <canvas id="simCanvas"></canvas>
  </main>

  <script>
    const g = 10;

    let state = {
      m1: 50,
      A1: 0.2,
      m2: 1300,
      A2: 2.0,
      F1: 500,  // Added to state for canvas drawing
      F2: 5000, // Added to state for canvas drawing
      deltaH1: 0,
      isPushing: false,
      canLift: false,
      loadType: "vehicle",      
      vehicleLabel: "Medium car"
    };

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const warningMsg = document.getElementById('warningMsg');
    const pushBtn = document.getElementById('pushBtn');
    const liftSound = document.getElementById('liftSound');

    const sliders = {
      m1: document.getElementById('m1Slider'),
      A1: document.getElementById('a1Slider'),
      A2: document.getElementById('a2Slider'),
      m2: document.getElementById('m2Slider')
    };

    const loadTypeSelect = document.getElementById('loadTypeSelect');
    const vehicleSelect = document.getElementById('vehicleSelect');
    const vehicleRow = document.getElementById('vehicleRow');
    const m2Row = document.getElementById('m2Row');

    const vehicleSpecs = {
      "900":  { label: "Small car", color: "#22c55e", roof: "compact" },
      "1300": { label: "Medium car", color: "#f59e0b", roof: "sedan" },
      "1700": { label: "Slightly bigger car", color: "#ef4444", roof: "suv" }
    };

    function startLiftSound() {
      if (!liftSound.paused) return;
      liftSound.currentTime = 0;
      liftSound.play().catch(() => {});
    }

    function stopLiftSound() {
      if (liftSound.paused) return;
      liftSound.pause();
      liftSound.currentTime = 0;
    }

    function resizeCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);

      canvas.logicalWidth = rect.width;
      canvas.logicalHeight = rect.height;
      draw();
    }
    window.addEventListener('resize', resizeCanvas);

    function syncLoadControlsFromType() {
      state.loadType = loadTypeSelect.value;

      if (state.loadType === "vehicle") {
        vehicleRow.style.display = "";
        m2Row.style.display = "none";

        const selectedMass = vehicleSelect.value;
        state.m2 = parseFloat(selectedMass);
        state.vehicleLabel = vehicleSpecs[selectedMass].label;

        sliders.m2.value = String(state.m2);
        document.getElementById('m2Val').innerText = state.m2 + " kg";
      } else {
        vehicleRow.style.display = "none";
        m2Row.style.display = "";

        state.m2 = parseFloat(sliders.m2.value);
        state.vehicleLabel = "Custom load";
        document.getElementById('m2Val').innerText = state.m2 + " kg";
      }
    }

    function updateMath() {
      state.m1 = parseFloat(sliders.m1.value);
      state.A1 = parseFloat(sliders.A1.value);
      state.A2 = parseFloat(sliders.A2.value);

      syncLoadControlsFromType();

      const F1 = state.m1 * g;
      const P = F1 / state.A1;
      const W = state.m2 * g;
      const F2 = P * state.A2;
      const MA = state.A2 / state.A1;

      // Update state forces for canvas
      state.F1 = F1;
      state.F2 = F2;

      state.canLift = F2 >= W;

      document.getElementById('m1Val').innerText = state.m1 + " kg";
      document.getElementById('a1Val').innerText = state.A1.toFixed(2) + " m²";
      document.getElementById('a2Val').innerText = state.A2.toFixed(1) + " m²";
      document.getElementById('m2Val').innerText = state.m2 + " kg";

      document.getElementById('f1Live').innerText = F1.toFixed(1) + " N";
      document.getElementById('pLive').innerText = P.toFixed(1) + " Pa";
      document.getElementById('wLive').innerText = W.toFixed(1) + " N";

      const f2Element = document.getElementById('f2Live');
      f2Element.innerText = F2.toFixed(1) + " N";
      document.getElementById('maLive').innerText = MA.toFixed(2);

      const statusText = document.getElementById('statusText');
      if (state.canLift) {
        f2Element.className = "success-text";
        statusText.innerHTML =
          `${state.vehicleLabel}: F₂ (${F2.toFixed(0)} N) ≥ W (${W.toFixed(0)} N)<br>` +
          `<b style="color:#4ade80">System can lift the load.</b>`;
        warningMsg.style.opacity = "0";
      } else {
        f2Element.className = "alert-text";
        statusText.innerHTML =
          `${state.vehicleLabel}: F₂ (${F2.toFixed(0)} N) < W (${W.toFixed(0)} N)<br>` +
          `<b style="color:#f87171">Force too low to lift.</b>`;
      }

      if (!state.isPushing) {
        state.deltaH1 = 0;
      }

      draw();
    }

    Object.values(sliders).forEach(s => s.addEventListener('input', updateMath));
    loadTypeSelect.addEventListener('change', updateMath);
    vehicleSelect.addEventListener('change', updateMath);

    function resetLift() {
      state.deltaH1 = 0;
      warningMsg.style.opacity = "0";
      draw();
    }

    function drawInputArrow(cx, topY, length, f1Value) {
      ctx.strokeStyle = "#ef4444";
      ctx.lineWidth = 5;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(cx, topY);
      ctx.lineTo(cx, topY + length);
      ctx.stroke();

      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.moveTo(cx, topY + length + 16);
      ctx.lineTo(cx - 12, topY + length - 2);
      ctx.lineTo(cx + 12, topY + length - 2);
      ctx.closePath();
      ctx.fill();

      // Dynamic Font Scaling for F1 (ranging roughly from 12px to 28px)
      const fontSizeF1 = Math.max(12, Math.min(28, 12 + f1Value * 0.008));
      
      ctx.fillStyle = "#ffffff";
      ctx.font = `bold ${fontSizeF1}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText(`F₁ = ${f1Value.toFixed(0)} N`, cx, topY - 5);
      
      ctx.textBaseline = "alphabetic"; // Reset baseline
    }

    function drawCar(cx, yTop, width, height, spec) {
      const bodyColor = spec.color;

      ctx.fillStyle = bodyColor;
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;

      const bodyH = height * 0.52;
      const bodyY = yTop + height - bodyH;

      roundRect(ctx, cx - width/2, bodyY, width, bodyH, 10, true, true);

      ctx.beginPath();
      if (spec.roof === "compact") {
        ctx.moveTo(cx - width*0.26, bodyY);
        ctx.quadraticCurveTo(cx - width*0.08, yTop + height*0.2, cx + width*0.15, bodyY);
      } else if (spec.roof === "sedan") {
        ctx.moveTo(cx - width*0.30, bodyY);
        ctx.lineTo(cx - width*0.10, yTop + height*0.18);
        ctx.lineTo(cx + width*0.16, yTop + height*0.18);
        ctx.lineTo(cx + width*0.32, bodyY);
      } else {
        ctx.moveTo(cx - width*0.30, bodyY);
        ctx.lineTo(cx - width*0.22, yTop + height*0.16);
        ctx.lineTo(cx + width*0.20, yTop + height*0.16);
        ctx.lineTo(cx + width*0.30, bodyY);
      }
      ctx.closePath();
      ctx.fillStyle = bodyColor;
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "#cfe8ff";
      if (spec.roof === "compact") {
        ctx.beginPath();
        ctx.moveTo(cx - width*0.18, bodyY);
        ctx.quadraticCurveTo(cx - width*0.02, yTop + height*0.27, cx + width*0.08, bodyY);
        ctx.closePath();
        ctx.fill();
      } else if (spec.roof === "sedan") {
        ctx.beginPath();
        ctx.moveTo(cx - width*0.20, bodyY);
        ctx.lineTo(cx - width*0.06, yTop + height*0.24);
        ctx.lineTo(cx + width*0.11, yTop + height*0.24);
        ctx.lineTo(cx + width*0.21, bodyY);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.fillRect(cx - width*0.18, yTop + height*0.22, width*0.34, height*0.18);
      }

      const wheelY = yTop + height - 3;
      const r = Math.max(8, Math.min(14, width * 0.09));
      ["left", "right"].forEach(side => {
        const wx = side === "left" ? cx - width*0.24 : cx + width*0.24;
        ctx.fillStyle = "#111827";
        ctx.beginPath();
        ctx.arc(wx, wheelY, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#9ca3af";
        ctx.beginPath();
        ctx.arc(wx, wheelY, r*0.4, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 14px sans-serif";
      ctx.textAlign = "center";
     
      // Draw weight (W = m * g) in yellow just below it
      ctx.fillStyle = "red"; 
      ctx.font = "11px sans-serif";
      ctx.fillText(`W = ${state.m2 * g} N`, cx, bodyY + bodyH/2 + 30);
    }

    function drawCustomLoadBlock(cx, yTop, width, mass) {
      const blockW = Math.min(width, 120);
      const blockH = Math.max(32, Math.min(80, 28 + Math.sqrt(mass) * 0.8));
      const x = cx - blockW/2;
      const y = yTop - blockH;

      ctx.fillStyle = "#ea580c";
      ctx.strokeStyle = "#c2410c";
      ctx.lineWidth = 2;
      ctx.fillRect(x, y, blockW, blockH);
      ctx.strokeRect(x, y, blockW, blockH);

      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + blockW, y + blockH);
      ctx.moveTo(x + blockW, y);
      ctx.lineTo(x, y + blockH);
      ctx.stroke();

      ctx.fillStyle = "#fde047"; 
      ctx.font = "bold 12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(`W = ${state.m2 * g} N`, cx, bodyY + bodyH/2 + 4);
    }

    function draw() {
      const w = canvas.logicalWidth || 800;
      const h = canvas.logicalHeight || 500;
      ctx.clearRect(0, 0, w, h);

      const cx1 = w * 0.25;
      const cx2 = w * 0.75;
      const baseY = h * 0.85;

      const baseScale = 80;
      const w1 = Math.max(Math.sqrt(state.A1) * baseScale, 20);
      const w2 = Math.max(Math.sqrt(state.A2) * baseScale, 40);

      const defaultH = h * 0.40;
      const deltaH2 = state.deltaH1 * (state.A1 / state.A2);

      const h1 = defaultH - state.deltaH1;
      const h2 = defaultH + deltaH2;

      const pipeThickness = 8;

      // Outer pipe walls
      ctx.fillStyle = "#1e293b";
      ctx.beginPath();
      ctx.rect(cx1 - w1/2 - pipeThickness, baseY - defaultH - 80, w1 + pipeThickness*2, defaultH + 80 + pipeThickness);
      ctx.rect(cx2 - w2/2 - pipeThickness, baseY - defaultH - 180, w2 + pipeThickness*2, defaultH + 180 + pipeThickness);
      ctx.rect(cx1 - w1/2 - pipeThickness, baseY, (cx2 - cx1) + w2/2 + pipeThickness*2, w1 + pipeThickness*2);
      ctx.fill();

      // Inner pipe
      ctx.fillStyle = "#0f172a";
      ctx.beginPath();
      ctx.rect(cx1 - w1/2, baseY - defaultH - 80, w1, defaultH + 80);
      ctx.rect(cx2 - w2/2, baseY - defaultH - 180, w2, defaultH + 180);
      ctx.rect(cx1 - w1/2, baseY, (cx2 - cx1) + w2/2, w1);
      ctx.fill();

      // Fluid
      ctx.fillStyle = "rgba(234, 179, 8, 0.72)";
      ctx.beginPath();
      ctx.moveTo(cx1 - w1/2, baseY - h1);
      ctx.lineTo(cx1 + w1/2, baseY - h1);
      ctx.lineTo(cx1 + w1/2, baseY);
      ctx.lineTo(cx2 - w2/2, baseY);
      ctx.lineTo(cx2 - w2/2, baseY - h2);
      ctx.lineTo(cx2 + w2/2, baseY - h2);
      ctx.lineTo(cx2 + w2/2, baseY + w1);
      ctx.lineTo(cx1 - w1/2, baseY + w1);
      ctx.closePath();
      ctx.fill();

      // Fluid surfaces
      ctx.strokeStyle = "#eab308";
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(cx1 - w1/2, baseY - h1); ctx.lineTo(cx1 + w1/2, baseY - h1); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx2 - w2/2, baseY - h2); ctx.lineTo(cx2 + w2/2, baseY - h2); ctx.stroke();

      // Pistons
      ctx.fillStyle = "#94a3b8";
      ctx.fillRect(cx1 - w1/2 + 2, baseY - h1 - 15, w1 - 4, 15);

      ctx.fillStyle = "#94a3b8";
      ctx.fillRect(cx2 - w2/2 + 2, baseY - h2 - 20, w2 - 4, 20);

      // Input side: Draw Arrow with dynamically scaling F1 text
      drawInputArrow(cx1, baseY - h1 - 75, 38, state.F1);

      // Output side: car OR custom block
      const topOfLargePiston = baseY - h2 - 20;
      let loadHeight = 0;
      
      if (state.loadType === "vehicle") {
        const spec = vehicleSpecs[String(state.m2)] || vehicleSpecs["1300"];
        const carW = Math.min(w2 - 12, 120);
        loadHeight = Math.max(36, Math.min(62, 34 + (state.m2 - 900) * 0.02));
        const carTopY = topOfLargePiston - loadHeight;
        drawCar(cx2, carTopY, carW, loadHeight, spec);
      } else {
        loadHeight = Math.max(32, Math.min(80, 28 + Math.sqrt(state.m2) * 0.8));
        drawCustomLoadBlock(cx2, topOfLargePiston, w2 - 10, state.m2);
      }

      // Draw dynamically scaling F2 Text above the load
      // Font size scales with the square root of F2 to keep it manageable across large numbers
      const fontSizeF2 = Math.max(12, Math.min(36, 12 + Math.sqrt(state.F2) * 0.06));
      ctx.fillStyle = "#38bdf8"; 
      ctx.font = `bold ${fontSizeF2}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      // Draw the upward arrow perfectly centered above the load
      ctx.fillText("⬆", cx2, topOfLargePiston - loadHeight - 5);
      
      // Draw the F2 text perfectly centered above the arrow
      ctx.fillText(`F₂ = ${state.F2.toFixed(0)} N`, cx2, topOfLargePiston - loadHeight - fontSizeF2 - 10);
      ctx.textBaseline = "alphabetic"; // Reset

      // Labels at bottom
      ctx.fillStyle = "#e2e8f0";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";

    }

    function animate() {
      if (state.isPushing) {
        if (state.canLift) {
          state.deltaH1 += 2;
          if (state.deltaH1 > 150) state.deltaH1 = 150;
          warningMsg.style.opacity = "0";
        } else {
          warningMsg.style.opacity = "1";
        }
        draw();
      }
      requestAnimationFrame(animate);
    }

    // Press & hold handlers
    pushBtn.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      pushBtn.setPointerCapture(e.pointerId);
      state.isPushing = true;
      startLiftSound();
    });

    pushBtn.addEventListener('pointerup', () => {
      state.isPushing = false;
      warningMsg.style.opacity = "0";
      stopLiftSound();
    });

    pushBtn.addEventListener('pointercancel', () => {
      state.isPushing = false;
      warningMsg.style.opacity = "0";
      stopLiftSound();
    });

    pushBtn.addEventListener('pointerleave', () => {
      if (state.isPushing) {
        state.isPushing = false;
        warningMsg.style.opacity = "0";
        stopLiftSound();
      }
    });

    window.addEventListener('blur', () => {
      state.isPushing = false;
      warningMsg.style.opacity = "0";
      stopLiftSound();
    });

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // Init
    resizeCanvas();
    updateMath();
    requestAnimationFrame(animate);
  </script>
</body>
</html>
